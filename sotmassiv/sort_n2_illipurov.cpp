/*В файле содержится двумерный массив размерностью n × n. В новый файл вывести отсортированный массив.
2. Строки по возрастанию с помощью сортировки подсчетом.*/
#include <iostream> 
#include <vector>    
#include <string>    
#include <fstream>   
#include <algorithm>  
using namespace std;

ifstream in("input.txt");        //ввод данных из файл
ofstream out("output_2.txt");    //вывод данных в файл

vector<vector<int>> inFile(int n){  // заполнение массива данными из файла
    in >> n;                  // ввод размерности массива
    vector<vector<int>> x(n); // обЪявление вектoра векторов заданной размерности
    for (int i = 0; i < n; i++)
    {                               // проход по строкам, по внешнему вектору
        x[i].resize(n);             // определение размерности вектора текущей строки
        for (int j = 0; j < n; j++) // проход по столбцам в строке
            in >> x[i][j];          // заполняем текущий элемент
    }
    return x; // возвращаем заполненный массив
}

void outFile(vector<int> &x){ // вывод массива в файл
    int n = x.size(); // определение размерности
    for (int i = 0; i < n; i++){// проход по элементам массива
        out << x[i] << "\t"; // вывод текущего элемента
    }
    out << endl; // переход на новую строку
}

/*Сортировка подсчетом (Counting sort) - это алгоритм сортировки, в котором создается массив, который будет использоваться для подсчета количества
 каждого значения в исходном массиве. Затем этот массив используется для помещения каждого значения в правильную позицию в отсортированном массиве.*/
void sortirovka_podchetom(vector<int> &x){  // сортировка подсчетом
    int n = x.size();           // определение размерности массива
    int min = x[0], max = x[0]; // инициализация максимума и минимума в массиве
    for (int i = 0; i < n; i++){
        if (x[i] < min) // поиск минимума
            min = x[i];
        if (x[i] > max) // поиск максимума
            max = x[i];
    }

    int k = max - min + 1; // размерность вспомогательного массива с количеством повторений
    vector<int> b(k);      // вспомогательным массив с количеством вхождений

    for (int i = 0; i < k; i++)
        b.push_back(0);         // заполнение вспомогательного массива нулями
    for (int i = 0; i < n; i++) // проход по элементам массива
        b[x[i] - min]++;        // прибавляем к количеству вхождений для соответствующего элемента 1

    int l = 0; // индекс текущего элемента в конечном массиве
    for (int i = 0; i < k; i++)
    { // проход по вспомогательному массиву
        for (int j = 1; j <= b[i]; j++)
        {                   // количество повторений согласно элементу в вспомогательном массиве
            x[l] = i + min; // записывает соответствующий элемент в конечный массив
            l++;            // изменение индекса для текущего элемента конечного массива
        }
    }
}

int main()
{
    int n;                 // инициализация переменной размерности массива
    vector<vector<int>> x; // обЪявление вектора векторов исходного
    x = inFile(n);         // ввод данных из файла
    for (int i = 0; i < n; i++)
    {                               // проход по строкам исходного массива
        sortirovka_podchetom(x[i]); // вызов функции сортировки текущей сторки
        outFile(x[i]);              // вывод в файл массива текущей строки
    }
}